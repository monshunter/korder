# Business Pod Examples Using DaemonSet Reservations
# These examples show how business pods can utilize resources reserved by DaemonSet orders

---
# Example 1: Monitoring agent using reserved resources
apiVersion: v1
kind: Pod
metadata:
  name: prometheus-node-exporter
  namespace: korder-system
  annotations:
    # Request to use korder reserved resources
    korder.dev/required: "true"
    # Specify which order to use
    korder.dev/order: "monitoring-agent-reservation"
  labels:
    app: prometheus-node-exporter
    tier: monitoring
spec:
  containers:
  - name: node-exporter
    image: prom/node-exporter:latest
    ports:
    - containerPort: 9100
      name: metrics
    resources:
      requests:
        cpu: 100m
        memory: 200Mi
      limits:
        cpu: 200m
        memory: 400Mi
    volumeMounts:
    - name: proc
      mountPath: /host/proc
      readOnly: true
    - name: sys
      mountPath: /host/sys
      readOnly: true
  volumes:
  - name: proc
    hostPath:
      path: /proc
  - name: sys
    hostPath:
      path: /sys
  hostNetwork: true
  hostPID: true

---
# Example 2: Log collection agent
apiVersion: v1
kind: Pod
metadata:
  name: fluentd-log-collector
  namespace: logging
  annotations:
    korder.dev/required: "true"
    korder.dev/order: "log-collector-buffer"
  labels:
    app: fluentd
    tier: logging
spec:
  containers:
  - name: fluentd
    image: fluent/fluentd:latest
    resources:
      requests:
        cpu: 100m
        memory: 256Mi
        ephemeral-storage: 1Gi
      limits:
        cpu: 200m
        memory: 512Mi
        ephemeral-storage: 2Gi
    volumeMounts:
    - name: varlog
      mountPath: /var/log
      readOnly: true
    - name: varlibdockercontainers
      mountPath: /var/lib/docker/containers
      readOnly: true
    - name: fluentd-config
      mountPath: /fluentd/etc
  volumes:
  - name: varlog
    hostPath:
      path: /var/log
  - name: varlibdockercontainers
    hostPath:
      path: /var/lib/docker/containers
  - name: fluentd-config
    configMap:
      name: fluentd-config

---
# Example 3: Security scanning agent
apiVersion: v1
kind: Pod
metadata:
  name: security-scanner
  namespace: security
  annotations:
    korder.dev/required: "true"
    korder.dev/order: "security-scanner-reservation"
  labels:
    app: security-scanner
    tier: security
spec:
  containers:
  - name: scanner
    image: aquasec/trivy:latest
    command: ["sleep", "3600"]  # Keep running for scanning
    resources:
      requests:
        cpu: 50m
        memory: 128Mi
      limits:
        cpu: 100m
        memory: 256Mi
    volumeMounts:
    - name: docker-socket
      mountPath: /var/run/docker.sock
      readOnly: true
  volumes:
  - name: docker-socket
    hostPath:
      path: /var/run/docker.sock
  securityContext:
    privileged: true

---
# Example 4: Edge processing workload
apiVersion: v1
kind: Pod
metadata:
  name: edge-data-processor
  namespace: edge-computing
  annotations:
    korder.dev/required: "true"
    korder.dev/order: "edge-node-reservation"
  labels:
    app: edge-processor
    tier: edge
spec:
  containers:
  - name: processor
    image: nginx:alpine  # Placeholder for edge processing app
    resources:
      requests:
        cpu: 200m
        memory: 512Mi
      limits:
        cpu: 500m
        memory: 1Gi
    env:
    - name: EDGE_MODE
      value: "true"
    - name: LOCAL_PROCESSING
      value: "enabled"

---
# Example 5: GPU workload using buffer resources
apiVersion: v1
kind: Pod
metadata:
  name: gpu-training-job
  namespace: default
  annotations:
    korder.dev/required: "true"
    korder.dev/order: "gpu-node-buffer"
  labels:
    app: gpu-training
    tier: ml
spec:
  containers:
  - name: training
    image: tensorflow/tensorflow:latest-gpu
    resources:
      requests:
        cpu: 500m
        memory: 1Gi
        nvidia.com/gpu: 1
      limits:
        cpu: 1000m
        memory: 2Gi
        nvidia.com/gpu: 1
    env:
    - name: CUDA_VISIBLE_DEVICES
      value: "0"

---
# Example 6: DaemonSet that uses reserved resources
# This shows how a DaemonSet itself can benefit from reserved resources
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: network-monitoring
  namespace: korder-system
spec:
  selector:
    matchLabels:
      app: network-monitor
  template:
    metadata:
      labels:
        app: network-monitor
      annotations:
        korder.dev/required: "true"
        korder.dev/order: "monitoring-agent-reservation"
    spec:
      containers:
      - name: network-monitor
        image: nicolaka/netshoot:latest
        command: ["sleep", "infinity"]
        resources:
          requests:
            cpu: 100m
            memory: 200Mi
          limits:
            cpu: 200m
            memory: 400Mi
        securityContext:
          capabilities:
            add: ["NET_ADMIN", "NET_RAW"]
      hostNetwork: true
      tolerations:
      - operator: Exists
